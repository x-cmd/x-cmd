# shellcheck shell=dash disable=SC2016

# If there is a mac address with the more than 1 ip, high light it.

___x_cmd_arp_ls(){
    local format=auto
    local all=no
    local vendor=1

    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)        ___x_cmd help -m arp ls ; return 0 ;;

            -n|--no-vendor)
                              vendor="";           shift ;;

            -c|--csv)         format=csv;          shift ;;
            -t|--tsv)         format=tsv;          shift ;;
            -r|--raw)         format=raw;          shift ;;
            --auto|--app)     format="${1#--}";    shift ;;
            -a|--all)         all=yes;             shift ;;
            -*)               N=arp M="Unknown option -> $1" log:ret:64 ;;
            *)                break ;;
        esac
    done

    ___x_cmd_arp_ls_"$format" "$@"
}

___x_cmd_arp_ls_raw(){
    [ $# -gt 0 ] || set -- -a

    if ___x_cmd_hascmd arp; then
        if ___x_cmd os is win; then
            "${___X_CMD_ROOT_MOD}/arp/lib/ls/arp.bat" "$@"
        else
            ___x_cmd_cmds arp -n "$@"
        fi
    elif ___x_cmd os is linux; then
        arp:info "arp command not found, use the busybox's arp command"
        ___x_cmd busybox arp -n "$@"
    else
        N=arp M="Command not found -> arp" log:ret:1
    fi
}

___x_cmd_arp_ls_auto(){
    if      ___x_cmd_is_stdout2tty; then        ___x_cmd_arp_ls_app
    else                                        ___x_cmd_arp_ls_tsv
    fi
}

___x_cmd_arp_ls_csv(){
    ___x_cmd_arp_ls_tsv | ___x_cmd tsv tocsv
}

___x_cmd_arp_ls_tsv(){
    if [ -z "$vendor" ]; then
        ___x_cmd_arp_ls_xsv "\t"
        return
    fi

    # TODO: A better way to implement no-vendor is, use the cache only and no request.

    # local data;     data="$(___x_cmd_arp_ls_xsv "\t")"
    # local maclist;  maclist="$(___x_cmd_pipevar data ___x_cmd cutt 2: 2 | ___x_cmd ip macvendor --pipe)"
    # ___x_cmd tsv merge "$data" "$maclist"


    {
        local data;     data="$(___x_cmd_arp_ls_xsv "\t")"
        printf "%s\n" "$data"

        printf "%s\n" "===ADD-COL==="
        # TODO: add region and vendor
        printf "%s\n" "vendor"
        ___x_cmd_pipevar data ___x_cmd cutt 2: 1 | ___x_cmd ma --pipe
    } | ___x_cmd tsv addcol

}

___x_cmd_arp_ls_xsv(){
    local x_=""
    ___x_cmd_arp_ls_raw | {
        ___x_cmd os name_
        local parsefp
        case "$x_" in
            linux)      parsefp="$___X_CMD_ROOT_MOD/arp/lib/ls/parse_linux_xsv.awk" ;;
            darwin)     parsefp="$___X_CMD_ROOT_MOD/arp/lib/ls/parse_darwin_xsv.awk" ;;
            win)        parsefp="$___X_CMD_ROOT_MOD/arp/lib/ls/parse_win_xsv.awk" ;;
        esac

        ___x_cmd_cmds awk   \
            -v OFS="$1"     -v all="$all"   \
            -f "$___X_CMD_ROOT_MOD/arp/lib/ls/parse___share.awk"    \
            -f "$parsefp"
    }
}


___x_cmd_arp_ls_app(){
    arp:info 'If the ARP table is incomplete, populate it using `x ip map <ip-subnet>`, for example, `x ip map 192.168.1.0/24`.'

    # ___x_cmd_arp_ls_csv | ___x_cmd csv app
    local ___X_CMD_CSV_APP_SHBIN_CODE=
    ___X_CMD_CSV_APP_SHBIN_CODE="xrc arp; local vendor=$vendor; local all=$all" \
        ___x_cmd csv app --clear ___x_cmd_arp_ls_csv  || return 1
}


___x_cmd_arp_ls_app___sort(){
    read -r line;
    printf "%s\n" "$line"
    ___x_cmd_cmds sort -k 2,1
}

___x_cmd_arp_ls_app___colorize(){
    ___x_cmd_cmds cat
}
