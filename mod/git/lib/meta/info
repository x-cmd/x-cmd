# shellcheck shell=dash

___x_cmd_git_meta_id(){
    ___x_cmd___git_origin rev-parse "${1:-HEAD}"
}


___x_cmd_git_meta_branch(){
    ___x_cmd___git_origin branch --show-current
}


___x_cmd_git_meta_tag(){
    ___x_cmd___git_origin describe --tags --exact-match 2>/dev/null
}

___x_cmd_git_meta_root_(){
    local s="${1:-$PWD}";   s="${s%/}"
    local x_=""
    if ___x_cmd locatefolder_ "${s}" .git/config; then      ___X_CMD_GIT_META_ROOT_="$x_"
    else                                                    ___X_CMD_GIT_META_ROOT_=
    fi
}

___x_cmd_git_meta_root(){
    local ___X_CMD_GIT_META_ROOT_
    ___x_cmd_git_meta_root_ "$@"
    printf "%s\n" "$___X_CMD_GIT_META_ROOT_"
}

___x_cmd_git_meta_owner(){
    local name; name=$(___x_cmd_git_meta_path) || return
    printf "%s\n" "${name%%/*}"
}

# TODO: just repo name
___x_cmd_git_meta_name(){
    ___x_cmd_git_meta_config | ___x_cmd_cmds_awk -v FS='=' '
$1~/^[ \t\b\v]+url[ \t\b\v]+$/{
    match($2, /[^:\/.]+\/[^.\/]+(.git)?$/)
    print substr($2, RSTART, RLENGTH)
}
' | sort | uniq
}

___x_cmd_git_meta_fullname(){
    ___x_cmd_git_meta_config | ___x_cmd_cmds_awk -v FS='=' '
$1~/^[ \t\b\v]+url[ \t\b\v]+$/{
    match($2, /[^:\/.]+\/[^.\/]+(.git)?$/)
    print substr($2, RSTART, RLENGTH)
}
' | sort | uniq
}

___x_cmd_git_meta_path(){
    ___x_cmd_git_meta_config | ___x_cmd_cmds_awk -v FS='=' '
$1~/^[ \t\b\v]+url[ \t\b\v]+$/{
    match($2, /[^:\/.]+\/[^.\/]+(.git)?$/)
    print substr($2, RSTART, RLENGTH)
}
' | sort | uniq
}

___x_cmd_git_meta_config(){
    local ___X_CMD_GIT_META_ROOT_
    ___x_cmd_git_meta_root_ "$PWD" || {
        git:error "Cannot locate .git/config"
        return 1
    }

    ___x_cmd_cmds_cat "$___X_CMD_GIT_META_ROOT_/.git/config"
}

___x_cmd_git_meta_url(){
    local name="${1:-origin}"
    command git config --worktree --get-regexp "remote\.${name}\.url" | \
        ___x_cmd_cmds_awk -v code=1 '{
            print $2; code=0;
        }
        END{ exit(code); }'
}
