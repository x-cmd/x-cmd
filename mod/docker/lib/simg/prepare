

# s/alpine/openjdk11:abc
# s/alpine/openjdk11:abc/_npm/pixiabc/asdf/sadf/asdf/work1/work2/_apk/abc:abc

___x_cmd_docker_simg_prepare(){
    local x_="";
    ___x_cmd_docker_simg_prepare_ "$@" || return $?
    printf "%s\n" "$x_"
}

# xd simg prep --alpine apt:java
# xd simg prep --alpine apt/nodejs:node

# s/alpine/base
# s/alpine/apt/openjdk1.1/
# s/alpine/go:go

___x_cmd_docker_simg_prepare_(){
    local cmd=auto
    local imgtype=alpine

    local mode=""

    arg:init docker
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)              ___x_cmd help -m docker simg prepare_ "$@"; return 0 ;;

            --imagetype)            imgtype="${2}";     arg:2:shift ;;

            --mode)                 mode="${2}";        arg:2:shift ;;
            *)                      break ;;
        esac
    done

    local cmd="$1"

    [ -z "$mode" ] || { ___x_cmd_docker_simg_prepare___"$mode"; return $?;  }

    local errcode=0

    x_="";  ___x_cmd_docker_simg_prepare___base_ || {
        errcode=$?
        docker:warn "Fail to prepare base image."
        return $errcode
    }
    local baseimg="$x_"

    ! ___x_cmd_docker cmdinfo hascmd "$baseimg" "$REFIT_CMD" || return 0

    local errcode=""
    local REFIT_PKG="";    local REFIT_SYS="";  local REFIT_CMD="$cmd";
    ___x_cmd_docker_snap___parse__ "$REFIT_CMD" "$imgtype" || {
        errcode=$?
        docker:warn "Unknown command recipe in ___x_cmd_docker_simg_prepare_ -> $REFIT_CMD"
        return $errcode
    }

    docker:debug --cmd "$REFIT_CMD" --sys "$REFIT_SYS" --pkg "$REFIT_PKG" "___x_cmd_docker_simg_prepare___refit_"

    ___x_cmd_docker_simg_prepare___refit_ "$baseimg"
}

___x_cmd_docker_simg_prepare___base_(){
    ___x_cmd_docker_snap___imageprefix_ "$imgtype" || return $?
    x_="${x_}-base"
    ! ___x_cmd_docker image exist "$x_"             || return 0

    case "$imgtype" in
        alpine)
            ___x_cmd_docker_simg_download --if0 --imagetype alpine        || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from alpine                   \
                --to "$x_"                      \
                --userabc                       \
                --apk 'curl fzf jq yq xz sqlite bash'
                ;;

        debian|ubuntu)
            ___x_cmd_docker_simg_download --if0 --imagetype "$imgtype"    || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from "$imgtype"               \
                --to "$x_"                      \
                --userabc                       \
                --apt 'curl fzf jq yq xz-utils sqlite3 ca-certificates'
                ;;

        kali)
            ___x_cmd_docker_simg_download --if0 --imagetype "$imgtype"    || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from kalilinux/kali-rolling   \
                --to "$x_"                      \
                --userabc                       \
                --apt 'curl fzf jq yq xz-utils sqlite3 ca-certificates'
                ;;

        fedora)
            ___x_cmd_docker_simg_download --if0 --imagetype "$imgtype" || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from fedora                   \
                --to "$x_"                      \
                --userabc                       \
                --dnf 'curl fzf jq yq sqlite3'
                ;;

        arch)
            ___x_cmd_docker_simg_download --if0 --imagetype "$imgtype" || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from archlinux --to "$x_"     \
                --userabc                       \
                --pacman 'curl fzf jq yq sqlite3'
                ;;

        nixos)
            ___x_cmd_docker_simg_download --if0 --imagetype "$imgtype" || return $?
            ___x_cmd docker refit               \
                --epxbin                        \
                --from nixos/nix --to "$x_"     \
                --userabc                       \
                --nix 'curl fzf jq yq sqlite3'
                ;;

    esac
}

___x_cmd_docker_simg_prepare___refit_(){
    local baseimg="$1"

    docker:debug --img "$baseimg" --sys "$REFIT_SYS" --pkg "$REFIT_PKG" "___x_cmd_docker_simg_prepare___refit_"

    ___x_cmd_docker_simg_prepare___imgname_ "$imgtype" "$REFIT_SYS" "$REFIT_PKG"

    ! ___x_cmd_docker image exist "$x_" || {
        docker:debug "Image already created -> $x_"
        return 0
    }

    docker:info "now refitting image -> $x_"

    ___x_cmd docker refit                   \
        --epxbin                            \
        --from "$baseimg" --to "$x_"        \
        --userabc                           \
        --"$REFIT_SYS" "$REFIT_PKG"         || return $?
}

___x_cmd_docker_simg_prepare___imgname_(){
    local imgtype="$1"
    local sys="$2"
    local pkg="$3"

    ___x_cmd_docker_snap___imageprefix_ "$imgtype"

    docker:debug --img "$imgtype" --sys "$sys" --pkg "$pkg" --name "$x_" "Generate image name"

    case "$sys" in
        apt|apk|dnf|pacman)     ;;
        *)                      x_="${x_}-${sys}" ;;
    esac

    # using -- to seperate pkgs ...
    x_="${x_}-$( ___x_cmd_cmds awk -v "n=$pkg" '
        BEGIN{
            gsub("https://", "", n)
            gsub("github.com",      "gh", n)
            gsub("gitlab.com",      "gl", n)
            gsub("codeberg.org",    "cb", n)
            gsub("[=:\\/-@.\\[\\]]", "_", n);
            n = tolower(n);

            gsub( "(^[_]+)|([_]+$)", "", n )
            print n
        }
    ')"
}
