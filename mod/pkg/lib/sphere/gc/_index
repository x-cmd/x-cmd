# shellcheck    shell=dash

xrc:mod:lib pkg     sphere/gc/recycle   sphere/gc/remove    sphere/gc/safelist


# x env gc --rm python
# x env gc python

# x env gc # interactive

# Autogc:
# 1. exe long unused:
# Provide user a list of package that is : vert old-version + unused:
# Calculating the size of the packages suggested to be removed.

# 1. Remove some packages long unused
# 2. Select some packages to remove

# x env unuse python
# x env unuse java
# x env gc python java

___x_cmd_pkg_sphere_gc(){
    local op="$1"
    case "$op" in
        # Inner function
        run|safelist|exist|remove|recycle)
                    shift; ___x_cmd_pkg_sphere_gc_"$op" "$@" ;;
        -h|--help)  x help -m pkg gc ;;

        "")         ___x_cmd_pkg_sphere_gc_run ;;
        *)          ___x_cmd_pkg_sphere_gc_run --pkg "$@" ;;
        # *)          N=pkg M="sphere gc not such option '$op'" log:ret:64
    esac
}

___x_cmd_pkg_sphere_gc_safelist(){
    [ "$#" -gt 0 ] || set -- -h
    local op="$1"; shift
    case "$op" in
        add)
            ___x_cmd_pkg_sphere_safelist add --reason "use,gc-safelist" "$@"
            ;;
        ls|exist|rm)
            ___x_cmd_pkg_sphere_safelist "$op" "$@"
            ;;
        *)  N=pkg M="gc safelist not such option '$op'" log:ret:64 ;;
    esac
}

___x_cmd_pkg_sphere_gc_exist(){
    pkg:sphere:parse:option
    local gcfp="$___X_CMD_PKG_ROOT_SPHERE/$sphere_name/.x-cmd/gc/Start"
    [ -f "$gcfp" ] || return 1
    # ! x fsiter --dirempty "$gcdir"
    ! ___x_cmd_pkg_sphere_gc___defuselock "$gcfp"
}


___x_cmd_pkg_sphere_gc___defuselock(){
    local gcfp="$1"
    [ -f "$gcfp" ] || return

    local bombpid;
    local fingerprint;
    {
        read -r bombpid
        read -r fingerprint
    } < "$gcfp"

    if ___x_cmd_ps fingerprint check "$bombpid" "$fingerprint"; then
        pkg:warn "There is another process [PID=$bombpid] running gc"
        return 1
    else
        x rmrf "$gcfp"
    fi
}

xrc ps
___x_cmd_pkg_sphere_gc_run(){(  # Must be a subshell
    local noall=
    pkg:sphere:parse:option
    sphere_name="${sphere_name:-"X"}"

    case "$1" in
        --pkg)  shift; noall=1;;
    esac

    pkg:info "Initiating garbage collection for [sphere=$sphere_name]"

    local gcfp="$___X_CMD_PKG_ROOT_SPHERE/$sphere_name/.x-cmd/gc/Start"
    trap 'x rmrf "$gcfp";' EXIT

    if [ -f "$gcfp" ]; then
        ___x_cmd_pkg_sphere_gc___defuselock "$gcfp" || return
    fi

    x ensurefp "$gcfp";

    local x_=;
    ___x_cmd_pidofsubshell_;        local spid="$x_"
    ___x_cmd_ps fingerprint get_;   local fingerprint="$x_"
    printf "%s\n" "$spid" "$fingerprint" >"$gcfp"

    ___x_cmd_cmds sync -f "$gcfp"
    sleep 1 # long enough to make sure file written

    local winner_pid
    read -r winner_pid <"$gcfp";

    if [ ! "$winner_pid" = "$spid" ]; then
        pkg:info "Abort because other process [PID=$winner_pid] win the gc lock."
        return
    fi

    if [ -t 1 ] && ___x_cmd_is_interactive; then
        if [ -z "$noall" ]; then    ___x_cmd_pkg_sphere_gc_run___interactive_all || return
        else                        ___x_cmd_pkg_sphere_gc_run___interactive_pkg "$@" || return
        fi
    fi
    ___x_cmd_pkg_sphere_gc_run___inner "$gcfp"
)}

# shellcheck disable=2120
___x_cmd_pkg_sphere_gc_run___interactive_all(){
    local l=; local osarch=; local name=; local version=;
    local list; list="$( ___x_cmd_pkg_sphere_safelist___ls_human --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" )"
    if [ -n "$list" ]; then
        list="$( trap -- '' EXIT; x pick --width 65 --col 3 --limit no-limit --ask "Using Tab to select the pkg you want to remove from the safelist." printf "%s\n" "$list" )" || return
        printf "%s\n" "$list" | while read -r l; do
            [ -n "$l" ] || continue
            [ "${l%%" ("*}" = "$l" ] || l="${l%%" ("*}"
            osarch="${l%% *}"; l="${l#* }"
            name="${l%% *}"; l="${l#* }"
            version="${l% *}"

            ___x_cmd_pkg_sphere_gc_run___interactive_unit_ || return
        done
    fi
}

___x_cmd_pkg_sphere_gc_run___interactive_pkg(){
    local l=; local osarch=; local name=; local version=;
    ___x_cmd_pkg_sphere_safelist___parse_arg "$@" | while read -r l; do
        name="${l%%/*}"; l="${l#*/}"
        version="${l%%/*}";
        osarch="${l#*/}"

        ___x_cmd_pkg_sphere_gc_run___interactive_unit_ || return
    done
}

___x_cmd_pkg_sphere_gc_run___interactive_unit_(){
    if ___x_cmd_pkg_sphere_link exist --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" \
        --osarch "$osarch" "$name" "$version"; then
        x ui yesno "Whether unuse to unlinked [name=$name] [version=$version] [osarch=$osarch]" || return
        pkg:debug "Unlinked [name=$name] [version=$version] [osarch=$osarch]"
        ___x_cmd_pkg_sphere_link rm  --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" --osarch "$osarch" "$name" "$version" || return
    fi

    x ui yesno "Whether remove ${name}=${version} from safelist in [sphere=$sphere_name]" || return
    ___x_cmd_pkg_sphere_safelist rm  --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" --osarch "$osarch" "${name}=${version}" || return
}

# TODO: A = ALL packages
# TODO: B = islink + safelist + DEPEENCYLIST
# TODO: C = candidates = A - B
___x_cmd_pkg_sphere_gc_run___inner(){
    local gcfp="$1"
    local gc_loop_continue=1; local l=; local name=; local version=;
    while [ -n "$gc_loop_continue" ]; do
        gc_loop_continue=

        while read -r l; do
            [ -n "$l" ] || continue
            name="${l%%/*}"
            version="${l#*/}"

            ___x_cmd_pkg_sphere_gc_recycle \
                --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" \
                --osarch "$osarch" "$name" "$version" || continue

            pkg:info "gc ==> trying to remove $name $version"
            ___x_cmd_pkg_sphere_gc_remove silent \
                --sphere "$sphere_name" --sphereroot "$___X_CMD_PKG_ROOT_SPHERE" \
                --osarch "$osarch" "$name" "$version" "$gcfp" || {
                pkg:warn "gc ==> failed to remove $name $version"
                continue
            }
            gc_loop_continue=1
        done <<A
$(___x_cmd_pkg_ls___installed)
A
    done
}
