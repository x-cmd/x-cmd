

___x_cmd_coco_enactall(){
    # TODO: using fifo
    local folder="$1"
    ___x_cmd_coco_enactall___draw "$folder" || return $?
    ___x_cmd_coco_enactall___tool "$folder"
}

___x_cmd_coco_enactall___draw(){
    [ "$is_enactnone" != 1 ] || return 0
    ___x_cmd price check || return $?

    local folder="$1"
    local datafile="$folder/draw"
    [ -f "$datafile" ] || N=coco M="Not found draw file -> $datafile" log:ret:1

    local is_interactive="$XCMD_CHAT_IS_INTERACTIVE"
    [ -n "$is_interactive" ] || {
        if ___x_cmd_is_stdout2tty && ___x_cmd_runmode_allow_chatty; then
            is_interactive=1
        fi
    }
    local is_tool_force="$XCMD_CHAT_IS_TOOL_FORCE"

    {
        ___x_cmd pidofsubshell
        exec tail -F -n "10000" "$datafile"
    } | {(
        local pid_of_upstream_pid
        read -r pid_of_upstream_pid
        trap "kill -s TERM $pid_of_upstream_pid" EXIT

        ___x_cmd_coco_enactall___draw_awk "$is_interactive"
    )}
}

___x_cmd_coco_enactall___draw_awk(){
    local is_interactive="$1"
    ___x_cmd tty update

    local x_=""; ___x_cmd locale money_ || return $?
    local money_unit="$x_"

    is_interactive="$is_interactive" \
    money_unit="$money_unit" \
    LINES="$LINES" \
    ___X_CMD_UI_ROTATE_SIZE=10 \
    ___X_CMD_UI_ROTATE_TEXT_COLOR="\033[36m" \
    ___X_CMD_PRICE_DATA_DIR="$___X_CMD_PRICE_DATA_DIR" \
    ___x_cmd cawk -m j/json,j/jiter,ui/ui,ui/rotate,re,date \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxdetect.awk"    \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxbody.awk"      \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxcodeblock.awk" \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxmd.awk"        \
        -f "$___X_CMD_ROOT_MOD/price/lib/awk/llmp.awk"          \
        -f "$___X_CMD_ROOT_MOD/coco/lib/awk/handle_drawfile_data.awk"
}

___x_cmd_coco_enactall___tool(){
    local folder="$1"
    local datafile="$folder/log"
    [ -f "$datafile" ] || N=coco M="Not found log file -> $datafile" log:ret:1
    {
        ___x_cmd pidofsubshell
        exec tail -F -n "10000" "$datafile"
    } | {(
        [ "$is_enactnone" != 1 ] || ___x_cmd log coco/warn 2>/dev/null

        local pid_of_upstream_pid
        read -r pid_of_upstream_pid
        trap "kill -s TERM $pid_of_upstream_pid" EXIT

        local log
        local fcidx
        local expected_count=-1
        local finish_count=0
        local exitcode=0
        local conversation_text

        while read -r log; do
            case "$log" in
                "[BREAK] "*)
                    exitcode="${log#*"[BREAK] "}"
                    return "$exitcode" ;;
                "[FUNCTION-CALL] "*)
                    fcidx="${log#*"[FUNCTION-CALL] "}"
                    ___x_cmd_coco_enactall___tool_1 "$folder" "$fcidx"
                    ;;

                "[FUNCTION-CALL-COUNT] "*)
                    expected_count="${log#*"[FUNCTION-CALL-COUNT] "}"
                    [ "$expected_count" -gt 0 ] || break
                    ;;
                "[FUNCTION-CALL-END] "*)
                    finish_count="$((finish_count+1))"
                    if [ "$expected_count" -gt 0 ] && [ "$finish_count" -ge "$expected_count" ]; then
                        printf "[CONTINUE-CONVERSATION] %s\n"  "Function execution completed. Based on the result and context, proceed directly with the next action or response." >> "$datafile"
                    fi
                    ;;
                "[CONTINUE-CONVERSATION] "*)
                    conversation_text="${log#*"[CONTINUE-CONVERSATION] "}"
                    coco:info "Continue the conversation"
                    ___x_cmd chat --exec-raw "" "${history_num:-"$def_histnum"}" "$conversation_text" || return $?
                    break
                    ;;
            esac
        done
    )}
}

___x_cmd_coco_enactall___tool_1(){
    local folder="$1"
    local fcidx="$2"
    local fcall_dir="$folder/function-call/$fcidx"

    [ ! -e "$fcall_dir/exitcode" ] || {
        return 0
    }

    local fcall_name=""
    local fcall_arg=""

    read -r fcall_name  <"$fcall_dir/name"
    read -r fcall_arg   <"$fcall_dir/arg"
    read -r fcall_desc  <"$fcall_dir/desc"

    if ___x_cmd_coco_toolspec___check "$fcall_name"; then
        ___x_cmd_coco_tool___enactcmd           \
            "$folder"                           \
            "$fcidx"                            \
            "$fcall_name" "$fcall_arg" "$fcall_desc"
    else
        coco:error "Unknown tool calling -> $fcall_name"
        coco:error "Unknown tool calling -> $fcall_name" 2>"$fcall_dir/stderr"
        printf "%s\n" "1"       > "$fcall_dir/exitcode"
        printf "%s\n" "failed"  > "$fcall_dir/status"
        return 1
    fi
}

