

___x_cmd_coco_enactall(){
    # TODO: using fifo
    local folder="$1"
    ___x_cmd_coco_enactall___draw "$folder" || return $?
    ___x_cmd_coco_enactall___tool "$folder"
}

___x_cmd_coco_enactall___draw(){
    [ "$is_enactnone" != 1 ] || return 0
    ___x_cmd price check || return $?

    local folder="$1"
    local datafile="$folder/draw"
    [ -f "$datafile" ] || N=coco M="Not found draw file -> $datafile" log:ret:1

    local is_interactive="$XCMD_CHAT_IS_INTERACTIVE"
    [ -n "$is_interactive" ] || {
        if ___x_cmd_is_stdout2tty && ___x_cmd_runmode_allow_chatty; then
            is_interactive=1
        fi
    }

    {
        ___x_cmd pidofsubshell
        exec tail -F -n "10000" "$datafile"
    } | {(
        local pid_of_upstream_pid
        read -r pid_of_upstream_pid
        trap "kill -s TERM $pid_of_upstream_pid" EXIT

        ___x_cmd_coco_enactall___draw_awk "$is_interactive"
    )}
}

___x_cmd_coco_enactall___draw_awk(){
    local is_interactive="$1"
    ___x_cmd tty update

    local x_=""; ___x_cmd locale money_ || return $?
    local money_unit="$x_"

    is_interactive="$is_interactive" \
    money_unit="$money_unit" \
    LINES="$LINES" \
    ___X_CMD_UI_ROTATE_SIZE=10 \
    ___X_CMD_UI_ROTATE_TEXT_COLOR="\033[36m" \
    ___X_CMD_PRICE_DATA_DIR="$___X_CMD_PRICE_DATA_DIR" \
    ___x_cmd cawk -m j/json,j/jiter,ui/ui,ui/rotate,re,date \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxdetect.awk"    \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxbody.awk"      \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxcodeblock.awk" \
        -f "$___X_CMD_ROOT_MOD/md/lib/awk/llm/xxxmd.awk"        \
        -f "$___X_CMD_ROOT_MOD/price/lib/awk/llmp.awk"          \
        -f "$___X_CMD_ROOT_MOD/coco/lib/awk/handle_drawfile_data.awk"
}

___x_cmd_coco_enactall___tool(){
    local folder="$1"
    local datafile="$folder/log"
    [ -f "$datafile" ] || N=coco M="Not found log file -> $datafile" log:ret:1
    {
        ___x_cmd pidofsubshell
        exec tail -F -n "10000" "$datafile"
    } | {(
        [ "$is_enactnone" != 1 ] || ___x_cmd log coco/warn 2>/dev/null

        local pid_of_upstream_pid
        read -r pid_of_upstream_pid
        trap "kill -s TERM $pid_of_upstream_pid" EXIT

        local log
        local fcidx
        local expected_count=-1
        local finish_count=0
        local exitcode=0
        local conversation_text

        while read -r log; do
            case "$log" in
                "[BREAK] "*)
                    exitcode="${log#*"[BREAK] "}"
                    return "$exitcode" ;;
                "[FUNCTION-CALL] "*)
                    fcidx="${log#*"[FUNCTION-CALL] "}"
                    ___x_cmd_coco_enactall___tool_1 "$folder" "$fcidx"
                    ;;

                "[FUNCTION-CALL-COUNT] "*)
                    expected_count="${log#*"[FUNCTION-CALL-COUNT] "}"
                    [ "$expected_count" -gt 0 ] || break
                    ;;
                "[FUNCTION-CALL-END] "*)
                    finish_count="$((finish_count+1))"
                    if [ "$expected_count" -gt 0 ] && [ "$finish_count" -ge "$expected_count" ]; then
                        printf "[CONTINUE-CONVERSATION] %s\n"  "Function execution completed. Based on the result and context, proceed directly with the next action or response." >> "$datafile"
                    fi
                    ;;
                "[CONTINUE-CONVERSATION] "*)
                    conversation_text="${log#*"[CONTINUE-CONVERSATION] "}"
                    coco:info "Continue the conversation"
                    ___x_cmd chat --exec-raw "$conversation_text" "${history_num:-10}" || return $?
                    break
                    ;;
            esac
        done
    )}
}

___x_cmd_coco_enactall___tool_1(){
    local folder="$1"
    local fcidx="$2"
    local fcall_dir="$folder/function-call/$fcidx"

    [ ! -e "$fcall_dir/errcode" ] || {
        return 0
    }

    local fcall_name=""
    local fcall_arg=""

    read -r fcall_name  <"$fcall_dir/name"
    read -r fcall_arg   <"$fcall_dir/arg"
    read -r fcall_desc  <"$fcall_dir/desc"

    case "$fcall_name" in
        findgrep|readfile|writefile|diffv4a|mcp|shcmd|create_temp_path|histsum|update_stats|get_x_cmd_help|get_x_cmd_help_unit)
            ___x_cmd_coco_tool___enactcmd           \
                "$folder"                           \
                "$fcidx"                            \
                "$fcall_name" "$fcall_arg" "$fcall_desc"
            ;;
        *)
            coco:error "Unknown tool calling -> $fcall_name"
            coco:error "Unknown tool calling -> $fcall_name" 2>"$fcall_dir/stderr"
            printf "%s\n" "1"       > "$fcall_dir/errcode"
            printf "%s\n" "failed"  > "$fcall_dir/status"
            return 1
            ;;
    esac
}

